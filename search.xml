<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>主题模板</title>
      <link href="/20221211/theme-template/"/>
      <url>/20221211/theme-template/</url>
      
        <content type="html"><![CDATA[<h1 id="主题模板"><a href="#主题模板" class="headerlink" title="主题模板"></a>主题模板</h1><p><a href="https://xutopia77.github.io/">https://xutopia77.github.io/</a></p><!-- top_img: https://gitee.com/xutopia66/imbd/raw/master/blogcover/1.jpg --><p>20200719104425712<br><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20200719104425712.png" alt="image-20211215000519144"></p><p>20200719103822090<br><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20200719103822090.png" alt="image-20211215000519144"></p><p><a href="https://gitee.com/xutopia66/imbd/raw/master/">https://gitee.com/xutopia66/imbd/raw/master/</a></p><p>categories:<br>keywords:<br>description:</p><p>comments:<br>cover:<br>toc:<br>toc_number:<br>toc_style_simple:<br>copyright:<br>copyright_author:<br>copyright_author_href:<br>copyright_url:<br>copyright_info:<br>mathjax:<br>katex:<br>aplayer:<br>highlight_shrink:<br>aside:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//libevent的http服务器简单实现方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="comment">//for struct evkeyvalq</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http_struct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http_compat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO    printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DBG    printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERR    printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHTTPD_SIGNATURE   <span class="string">&quot;httpd v 0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理模块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpd_handler</span><span class="params">(<span class="keyword">struct</span> evhttp_request *req, <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> output[<span class="number">2048</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端请求的URI(使用evhttp_request_uri或直接req-&gt;uri)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *uri;</span><br><span class="line">    uri = <span class="built_in">evhttp_request_uri</span>(req);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;uri=%s\n&quot;</span>, uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;uri=%s\n&quot;</span>, req-&gt;uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line">    <span class="comment">//decoded uri</span></span><br><span class="line">    <span class="type">char</span> *decoded_uri;</span><br><span class="line">    decoded_uri = <span class="built_in">evhttp_decode_uri</span>(uri);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;decoded_uri=%s\n&quot;</span>, decoded_uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析URI的参数(即GET方法的参数)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evkeyvalq</span> params;</span><br><span class="line">    <span class="comment">//将URL数据封装成key-value格式,q=value1, s=value2</span></span><br><span class="line">    <span class="built_in">evhttp_parse_query</span>(decoded_uri, &amp;params);</span><br><span class="line">    <span class="comment">//得到q所对应的value</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;q=%s\n&quot;</span>, <span class="built_in">evhttp_find_header</span>(&amp;params, <span class="string">&quot;q&quot;</span>));</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line">    <span class="comment">//得到s所对应的value</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;s=%s\n&quot;</span>, <span class="built_in">evhttp_find_header</span>(&amp;params, <span class="string">&quot;s&quot;</span>));</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(decoded_uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取POST方法的数据</span></span><br><span class="line">    <span class="type">char</span> *post_data = (<span class="type">char</span> *) <span class="built_in">EVBUFFER_DATA</span>(req-&gt;input_buffer);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;post_data=%s\n&quot;</span>, post_data);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出到客户端 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//HTTP header</span></span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Server&quot;</span>, MYHTTPD_SIGNATURE);</span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>);</span><br><span class="line">    <span class="comment">//输出的内容</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *buf;</span><br><span class="line">    buf = <span class="built_in">evbuffer_new</span>();</span><br><span class="line">    <span class="built_in">evbuffer_add_printf</span>(buf, <span class="string">&quot;It works!\n%s\n&quot;</span>, output);</span><br><span class="line">    <span class="built_in">evhttp_send_reply</span>(req, HTTP_OK, <span class="string">&quot;OK&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">evbuffer_free</span>(buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *help = <span class="string">&quot;http://localhost:8080\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-l &lt;ip_addr&gt; interface to listen on, default is 0.0.0.0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-p &lt;num&gt;     port number to listen on, default is 1984\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-d           run as a deamon\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-t &lt;second&gt;  timeout for a http request, default is 120 seconds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-h           print this help and exit\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%s&quot;</span>,help);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当向进程发出SIGTERM/SIGHUP/SIGINT/SIGQUIT的时候，终止event的事件侦听循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sig) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">        <span class="keyword">case</span> SIGHUP:</span><br><span class="line">        <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">        <span class="keyword">case</span> SIGINT:</span><br><span class="line">            <span class="built_in">event_loopbreak</span>();  <span class="comment">//终止侦听event_dispatch()的事件侦听循环，执行之后的代码</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP   , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM  , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT   , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGQUIT  , signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认参数</span></span><br><span class="line">    <span class="type">char</span> *httpd_option_listen = <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_port = <span class="number">8080</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_daemon = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_timeout = <span class="number">120</span>; <span class="comment">//in seconds</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;http server start %s:%d\n&quot;</span>, httpd_option_listen, httpd_option_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;l:p:dt:h&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span> :</span><br><span class="line">                httpd_option_listen = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span> :</span><br><span class="line">                httpd_option_port = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> :</span><br><span class="line">                httpd_option_daemon = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span> :</span><br><span class="line">                httpd_option_timeout = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> :</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="built_in">show_help</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否设置了-d，以daemon运行</span></span><br><span class="line">    <span class="keyword">if</span> (httpd_option_daemon) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成子进程成功，退出父进程</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用libevent创建HTTP Server */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化event API</span></span><br><span class="line">    <span class="built_in">event_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个http server</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evhttp</span> *httpd;</span><br><span class="line">    httpd = <span class="built_in">evhttp_start</span>(httpd_option_listen, httpd_option_port);</span><br><span class="line">    <span class="built_in">evhttp_set_timeout</span>(httpd, httpd_option_timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定generic callback</span></span><br><span class="line">    <span class="built_in">evhttp_set_gencb</span>(httpd, httpd_handler, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//也可以为特定的URI指定callback</span></span><br><span class="line">    <span class="comment">//evhttp_set_cb(httpd, &quot;/&quot;, specific_handler, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始事件监听，分发</span></span><br><span class="line">    <span class="built_in">event_dispatch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="built_in">evhttp_free</span>(httpd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 主题配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于libevent的多线程http服务器</title>
      <link href="/20221211/libevent/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8Bhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/20221211/libevent/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8Bhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="基于libevent的多线程http-server"><a href="#基于libevent的多线程http-server" class="headerlink" title="基于libevent的多线程http server"></a>基于libevent的多线程http server</h3><p>项目中的业务需要实现最基本的HTTP/1.0版本的web服务器，客户端能够使用GET、POST方法请求资源，项目是运行在嵌入式linux系统中的，并且某一时刻可能有大量并发请求，综合考虑，选择libevent实现一个多线程的http服务器。</p><p>本文使用的libevent的版本是libevent-2.1.12-stable。也是目前最新的稳定版本。</p><p>程序源代码可以见公众号 xutopia77 文章 <strong>基于libevent的多线程http服务器</strong></p><p>在开始论述之前，我希望读者对IO多路复用器（尤其是epoll），以及对reactor和proactor模式有个大致的理解。对于这两个方面，网络上已经有大量的文章了，我自己也写过很多，如果读者想要了解这两项内容，可以点击下面链接查阅： <a href="https://zhuanlan.zhihu.com/p/457920283">select，poll，epoll的区别以及使用方法</a>。</p><p>首先，libevent是什么，我们看下官方的介绍： </p><blockquote><p> The libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, libevent also support callbacks due to signals or regular timeouts.  </p><p> libevent API提供了一种机制，可以在文件描述符上发生特定事件或超时后执行回调函数。此外，libevent还支持由于信号或常规超时而产生的回调。 </p></blockquote><p>同时看一下百度百科对他的介绍</p><blockquote><p>Libevent 是一个用<a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80/105958">C语言</a><a href="https://baike.baidu.com/item/%E7%BC%96%E5%86%99/1517598">编写</a>的、轻量级的开源高性能事件通知库，主要有以下几个亮点：事件驱动（ event-driven），高性能;轻量级，专注于网络，不如 ACE 那么臃肿庞大；源代码相当精炼、易读；跨平台，支持 Windows、 Linux、 *BSD 和 Mac Os；支持多种 I/O <a href="https://baike.baidu.com/item/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF/5785640">多路复用技术</a>， epoll、 poll、 dev/poll、 select 和 kqueue 等；支持 I/O，定时器和信号等事件；注册事件优先级。</p><p>Libevent 已经被广泛的应用，作为底层的网络库；比如 memcached、 Vomit、 Nylon、 Netchat等等。</p></blockquote><p>简单的来讲，libevent是一个网络库，能够帮我们处理大量的网络编程细节，降低我们的网络编程门槛，并且它具备良好的跨平台能力。使用者只需要向它注册一些事件，它就会在合适的时机（比如可读、可写或定时事件触发时）调用我们对应的注册函数。</p><p>libevent包括事件管理、缓存管理、DNS、HTTP、缓存事件几大部分。事件管理包括各种IO（socket）、定时器、信号等事件；缓存管理是指evbuffer功能；DNS是libevent提供的一个异步DNS查询功能；</p><p>我们要实现http服务器，就是使用他的HTTP组件。HTTP是libevent的一个轻量级http实现，包括服务器和客户端。libevent也支持ssl，这对于有安全需求的网络程序非常的重要，但是其支持不是很完善，比如http server的实现就不支持ssl。</p><p>基于libevnet的单线程的使用方法见文章：</p><p><a href="https://zhuanlan.zhihu.com/p/458189076">基于libevent的http服务器实现</a>。</p><p>这里基于libevnet实现多线程的http服务器。</p><h3 id="libevent的多线程使用注意事项："><a href="#libevent的多线程使用注意事项：" class="headerlink" title="libevent的多线程使用注意事项："></a>libevent的多线程使用注意事项：</h3><p>对于libevnet是否支持多线程，很多资料都有争议，有的说支持，有的说不支持。对于多线程这个特性是否能够使用，只能说多线程多线程是怎么使用的，是怎么与libevent结合的。</p><p>1，对于不同的线程，使用不同的base，是可以的。</p><p>2，libevent的信号事件是不支持多线程的，因为里面使用了全局变量。</p><p>3，不同的线程使用相同的base，即在不同线程里的事件都注册到一个base上，这是不行的，即使加锁也不行，因为某个事件没有用event_set()设置为EV_PERSIST，当事件发生时，会被自动删除。有可能线程a在删除事件的时候，线程b却在添加事件，这样还是会出现并发问题。最后的结论是——不行！。</p><p>如果想要使用多线程，就需要每个线程中对应一个base，将线程里的事件注册到线程的base上。</p><p>下面是http多线程使用的使用方法</p><p>启动多线程http的服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> nfd = <span class="built_in">BindSocket</span>(port);<span class="comment">//监听端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nthreads; i++)</span><br><span class="line">&#123;</span><br><span class="line">WorkRoom* w = <span class="keyword">new</span> WorkRoom;<span class="comment">//每个线程独有的环境参数，不使用局部变量，防止离开局部作用域后失效</span></span><br><span class="line">    </span><br><span class="line">    w-&gt;base = <span class="built_in">event_init</span>();<span class="comment">//libevnet使用多线程，每个线程中使用一个base </span></span><br><span class="line">    </span><br><span class="line">    w-&gt;httpd = <span class="built_in">evhttp_new</span>(w-&gt;base);<span class="comment">//初始化http</span></span><br><span class="line">    </span><br><span class="line">    r = <span class="built_in">evhttp_accept_socket</span>(w-&gt;httpd, nfd);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">evhttp_set_gencb</span>(w-&gt;httpd, GenericHandler, <span class="keyword">this</span>);<span class="comment">//设置http路由 404</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">evhttp_set_cb</span>(w-&gt;httpd, <span class="string">&quot;/test&quot;</span>, ProcessRequest, <span class="keyword">this</span> );<span class="comment">//设置http路由</span></span><br><span class="line">    event* watchdogEv = <span class="built_in">event_new</span>(w-&gt;base, <span class="number">-1</span>, EV_PERSIST|EV_TIMEOUT, watchdog, w);<span class="comment">//每个base设置一个看门狗，可以做一些线程监控的工作</span></span><br><span class="line">    <span class="built_in">event_add</span>(watchdogEv, &amp;tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是开启事件分发线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">event_base_dispatch</span>( w-&gt;base );</span><br></pre></td></tr></table></figure><p>可以在看门狗中关闭事件分发循环，event_base_loopexit是可以设置延迟事件的，不设置是可以参数为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> delay = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">event_base_loopexit</span>(w-&gt;base, &amp;delay);</span><br></pre></td></tr></table></figure><p>http服务器停止时，需要注意资源释放，以免内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">event_free</span>(w-&gt;watchdogEv); </span><br><span class="line"></span><br><span class="line"><span class="built_in">evhttp_free</span>(w-&gt;httpd);</span><br><span class="line"></span><br><span class="line"><span class="built_in">event_base_free</span>(w-&gt;base);</span><br></pre></td></tr></table></figure><p>程序使用demo，只需要设置监听端口和要启动的线程数量即可，在程序停止的时候，调用stop会释放所有资源，避免内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">servers::HttpSrv s;</span><br><span class="line">s.<span class="built_in">start</span>(<span class="number">8080</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;http to stop\n&quot;</span>);</span><br><span class="line">s.<span class="built_in">stop</span>();</span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;http stop\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>程序源代码可以见公众号 xutopia77 文章 <strong>基于libevent的多线程http服务器</strong></p><p>程序运行结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch start</span><br><span class="line">dispatch start</span><br><span class="line">dispatch start</span><br><span class="line">dispatch start</span><br><span class="line">dispatch start</span><br><span class="line">http start port:8080, thNum:5</span><br><span class="line">http to stop</span><br><span class="line">dispatch stop</span><br><span class="line">dispatch stop</span><br><span class="line">dispatch stop</span><br><span class="line">dispatch stop</span><br><span class="line">dispatch stop</span><br><span class="line">http stop</span><br></pre></td></tr></table></figure><p>postman请求测试</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET http://192.168.31.106:8080/test</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>PostmanRuntime/7.28.4</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Postman-Token</span><span class="punctuation">: </span>7a99df83-e2b1-442b-9f07-272cf1b40ef8</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.31.106:8080</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate, br</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"> </span><br><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 15 Jan 2022 10:16:26 GMT</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>17</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=ISO-8859-1</span><br><span class="line"> </span><br><span class="line"><span class="attribute">Requested</span><span class="punctuation">: </span>/test</span><br></pre></td></tr></table></figure><p>本次在项目中用到了libevent库，目前程序运行基本稳定，没有出现异常情况， libevent是目前一个非常优秀的跨平台网络库，通过研究学习它，可以知道一个网络库的设计方法，虽然libevent库不是很胖发，但是他的设计思想还是很优秀的，但是短短的时间里想要彻底掌握所有的细节，还是有难度的，这里我只是简单的阐述了libevnet的基本运行机制和使用方法，没有做过多的深入研究，如果本章中有错误的地方，还希望读者朋友们能够指出来。</p><p>程序源代码可以见公众号 xutopia77 文章 <strong>基于libevent的多线程http服务器</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/20221210/hello-world/"/>
      <url>/20221210/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++的vector的使用方法</title>
      <link href="/20200720/c/C++%E7%9A%84vector%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/20200720/c/C++%E7%9A%84vector%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="c-的vector的使用方法，创建，初始化，插入，删除等。"><a href="#c-的vector的使用方法，创建，初始化，插入，删除等。" class="headerlink" title="c++的vector的使用方法，创建，初始化，插入，删除等。"></a>c++的vector的使用方法，创建，初始化，插入，删除等。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ex_vector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ex_vector01_main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//#######################################################################################</span></span><br><span class="line">    <span class="comment">//初始化vector的方法</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;                                 <span class="comment">//v1是一个空vector，它的潜在元素是int类型的，执行默认初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;                             <span class="comment">//v2包含v1所有元素的副本</span></span><br><span class="line">    <span class="comment">//这里尝试先给v1添加元素，后看看v2是什么情况</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v22 = v1;                           <span class="comment">//等价于v2(v1)，v2包含v1所有元素的副本</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">float</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">11.0</span>)</span></span>;                     <span class="comment">//v3包含10个重复的元素，每个元素的值都是11</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>)</span></span>;                             <span class="comment">//v4包含了10个重复执行了值初始化的对象</span></span><br><span class="line">    vector&lt;string&gt; v5&#123; <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;d&quot;</span> &#125;;          <span class="comment">//v5包含了4个元素</span></span><br><span class="line">    vector&lt;string&gt; v55 = &#123; <span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;d&quot;</span> &#125;;      <span class="comment">//等价于v5&#123; &quot;a&quot;,&quot;b&quot;,&quot;cc&quot;,&quot;d&quot; &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#######################################################################################</span></span><br><span class="line">    <span class="comment">//初始化使用圆括号和花括号的区别</span></span><br><span class="line">    <span class="comment">//使用圆括号是，提供的值是用来构造vector对象的</span></span><br><span class="line">    <span class="comment">//使用花括号是，想用列表初始化vector对象的，初始化过程会尽可能的把花括号内的值当做是元素的初始</span></span><br><span class="line">    <span class="comment">//  值的列表来处理，只有在无法执行列表初始化的时候才会尽可能的考虑其他初始化的方式</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">va1</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">//va1有10个元素，每个值都是0</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; va2&#123; <span class="number">10</span> &#125;;  <span class="comment">//va2有1个元素，该元素的值是10</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">va3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>; <span class="comment">//va3有10个元素，每个的值都是1</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; va4&#123; <span class="number">10</span>,<span class="number">1</span> &#125;;<span class="comment">//va4有两个元素，值分别是10，1</span></span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; va5&#123; <span class="string">&quot;hi&quot;</span> &#125;;     <span class="comment">//列表初始化：va5有一个元素</span></span><br><span class="line">    <span class="comment">//vector&lt;string&gt; va6(&quot;hi&quot;);     //错误，不能使用字符串字面值构建vector对象</span></span><br><span class="line">    <span class="comment">//这种就是不使用花括号内的值来初始化对象</span></span><br><span class="line">    vector&lt;string&gt; va7&#123; <span class="number">10</span> &#125;;       <span class="comment">//va7有10个默认初始化的元素</span></span><br><span class="line">    vector&lt;string&gt; va8&#123; <span class="number">10</span>,<span class="string">&quot;hi&quot;</span> &#125;;  <span class="comment">//va8有10个值为&quot;hi&quot;的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//#######################################################################################</span></span><br><span class="line">    <span class="comment">//向vector中添加元素</span></span><br><span class="line">    <span class="comment">//最常见的一种方式就是先定义一个空的vector，然后当运行时在逐一添加。</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vb1</span><span class="params">(<span class="number">2</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vb1.<span class="built_in">push_back</span>(i);<span class="comment">//依次把整数数值添加到vb2的末尾</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vb1.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vb1 is empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第一种循环方法：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;vb1 have &quot;</span> &lt;&lt; vb1.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; elements&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; vb1[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;第二种循环方法：&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;i:vb1)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:vb1)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot;, &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++的模板类编译的问题</title>
      <link href="/20200720/c/c++%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/20200720/c/c++%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%BC%96%E8%AF%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="c-问题小记"><a href="#c-问题小记" class="headerlink" title="c++问题小记"></a>c++问题小记</h1><h3 id="1，模板类编译的问题"><a href="#1，模板类编译的问题" class="headerlink" title="1，模板类编译的问题"></a>1，模板类编译的问题</h3><p>前两天在写代码时，把模板类的声明和分开放在两个文件中了，类似于下面这样：</p><p>stack.hpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STACK_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STACK_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">stack</span>();</span><br><span class="line">            ~<span class="built_in">stack</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>stack.cpp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &quot;stack.hpp&quot;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; stack&lt;Type&gt;::stack() &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Hello, stack &quot; &lt;&lt; this &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt; stack&lt;Type&gt;::~stack() &#123;</span><br><span class="line">        std::cerr &lt;&lt; &quot;Goodbye, stack &quot; &lt;&lt; this &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stack.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -c -o main.o main.cpp</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -c -o stack.o stack.cpp</span>   </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ -o main main.o stack.o</span>  </span><br><span class="line">main.o: In function `main&#x27;:  </span><br><span class="line">main.cpp:(.text+0xe): undefined reference to &#x27;stack&lt;int&gt;::stack()&#x27;  </span><br><span class="line">main.cpp:(.text+0x1c): undefined reference to &#x27;stack&lt;int&gt;::~stack()&#x27;  </span><br><span class="line">collect2: ld returned 1 exit status  </span><br><span class="line">make: *** [program] Error 1  </span><br></pre></td></tr></table></figure><p>提示找不到函数的定义</p><p>在网上寻找的答案如下：</p><p>It is not possible to write the implementation of a template class in a separate cpp file and compile. All the ways to do so, if anyone claims, are workarounds to mimic the usage of separate cpp file but practically if you intend to write a template class library and distribute it with header and lib files to hide the implementation, it is simply not possible.</p><p>To know why, let us look at the compilation process. The header files are never compiled. They are only preprocessed. The preprocessed code is then clubbed with the cpp file which is actually compiled. Now if the compiler has to generate the appropriate memory layout for the object it needs to know the data type of the template class.</p><p>Actually it must be understood that template class is not a class at all but a template for a class the declaration and definition of which is generated by the compiler at compile time after getting the information of the data type from the argument. As long as the memory layout cannot be created, the instructions for the method definition cannot be generated. Remember the first argument of the class method is the ‘this’ operator. All class methods are converted into individual methods with name mangling and the first parameter as the object which it operates on. The ‘this’ argument is which actually tells about size of the object which incase of template class is unavailable for the compiler unless the user instantiates the object with a valid type argument. In this case if you put the method definitions in a separate cpp file and try to compile it the object file itself will not be generated with the class information. The compilation will not fail, it would generate the object file but it won’t generate any code for the template class in the object file. This is the reason why the linker is unable to find the symbols in the object files and the build fails.</p><p>Now what is the alternative to hide important implementation details? As we all know the main objective behind separating interface from implementation is hiding implementation details in binary form. This is where you must separate the data structures and algorithms. Your template classes must represent only data structures not the algorithms. This enables you to hide more valuable implementation details in separate non-templatized class libraries, the classes inside which would work on the template classes or just use them to hold data. The template class would actually contain less code to assign, get and set data. Rest of the work would be done by the algorithm classes.</p><p>具体原因就是：</p><p>模板类其实就不是一个类，c++的编译器在编译.cpp产生二进制目标文件的时候，需要根据函数的参数类型来确定链接符号（编译器不编译.h文件）,而编译模板类的时候因为函数的参数类型都没有确定，所以也就不能产生链接符号，所以在编译阶段是不会报错的，但是在链接阶段就报错了。针对这种情况有三种解决办法，但是最优的还是把实现和声明都放在头文件中。如果不想让c++类显得臃肿，可以在类里面声明，在类外进行实现。</p><p>参考链接</p><p><a href="https://stackoverflow.com/questions/1724036/splitting-templated-c-classes-into-hpp-cpp-files-is-it-possible">https://stackoverflow.com/questions/1724036/splitting-templated-c-classes-into-hpp-cpp-files-is-it-possible</a></p><p><a href="https://www.zhihu.com/question/20630104">https://www.zhihu.com/question/20630104</a></p><p><a href="https://www.bbsmax.com/A/rV573nLE5P/">https://www.bbsmax.com/A/rV573nLE5P/</a></p><p><a href="https://blog.csdn.net/bangdingshouji/article/details/72832869?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control">https://blog.csdn.net/bangdingshouji/article/details/72832869?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-3.control</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于libevent的http服务器实现</title>
      <link href="/20200720/libevent/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/20200720/libevent/%E5%9F%BA%E4%BA%8Elibevent%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基于libevent的http服务器实现"><a href="#基于libevent的http服务器实现" class="headerlink" title="基于libevent的http服务器实现"></a>基于libevent的http服务器实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//libevent的http服务器简单实现方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span>     </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>     </span></span><br><span class="line"><span class="comment">//for struct evkeyvalq</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http_struct.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/http_compat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;event2/util.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO    printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_DBG    printf</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_ERR    printf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHTTPD_SIGNATURE   <span class="string">&quot;httpd v 0.0.1&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理模块</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">httpd_handler</span><span class="params">(<span class="keyword">struct</span> evhttp_request *req, <span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> output[<span class="number">2048</span>] = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">    <span class="type">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取客户端请求的URI(使用evhttp_request_uri或直接req-&gt;uri)</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *uri;</span><br><span class="line">    uri = <span class="built_in">evhttp_request_uri</span>(req);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;uri=%s\n&quot;</span>, uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;uri=%s\n&quot;</span>, req-&gt;uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line">    <span class="comment">//decoded uri</span></span><br><span class="line">    <span class="type">char</span> *decoded_uri;</span><br><span class="line">    decoded_uri = <span class="built_in">evhttp_decode_uri</span>(uri);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;decoded_uri=%s\n&quot;</span>, decoded_uri);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析URI的参数(即GET方法的参数)</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evkeyvalq</span> params;</span><br><span class="line">    <span class="comment">//将URL数据封装成key-value格式,q=value1, s=value2</span></span><br><span class="line">    <span class="built_in">evhttp_parse_query</span>(decoded_uri, &amp;params);</span><br><span class="line">    <span class="comment">//得到q所对应的value</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;q=%s\n&quot;</span>, <span class="built_in">evhttp_find_header</span>(&amp;params, <span class="string">&quot;q&quot;</span>));</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line">    <span class="comment">//得到s所对应的value</span></span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;s=%s\n&quot;</span>, <span class="built_in">evhttp_find_header</span>(&amp;params, <span class="string">&quot;s&quot;</span>));</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(decoded_uri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取POST方法的数据</span></span><br><span class="line">    <span class="type">char</span> *post_data = (<span class="type">char</span> *) <span class="built_in">EVBUFFER_DATA</span>(req-&gt;input_buffer);</span><br><span class="line">    <span class="built_in">sprintf</span>(tmp, <span class="string">&quot;post_data=%s\n&quot;</span>, post_data);</span><br><span class="line">    <span class="built_in">strcat</span>(output, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 输出到客户端 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//HTTP header</span></span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Server&quot;</span>, MYHTTPD_SIGNATURE);</span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain; charset=UTF-8&quot;</span>);</span><br><span class="line">    <span class="built_in">evhttp_add_header</span>(req-&gt;output_headers, <span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>);</span><br><span class="line">    <span class="comment">//输出的内容</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evbuffer</span> *buf;</span><br><span class="line">    buf = <span class="built_in">evbuffer_new</span>();</span><br><span class="line">    <span class="built_in">evbuffer_add_printf</span>(buf, <span class="string">&quot;It works!\n%s\n&quot;</span>, output);</span><br><span class="line">    <span class="built_in">evhttp_send_reply</span>(req, HTTP_OK, <span class="string">&quot;OK&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">evbuffer_free</span>(buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_help</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *help = <span class="string">&quot;http://localhost:8080\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-l &lt;ip_addr&gt; interface to listen on, default is 0.0.0.0\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-p &lt;num&gt;     port number to listen on, default is 1984\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-d           run as a deamon\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-t &lt;second&gt;  timeout for a http request, default is 120 seconds\n&quot;</span></span><br><span class="line">        <span class="string">&quot;-h           print this help and exit\n&quot;</span></span><br><span class="line">        <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;%s&quot;</span>,help);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当向进程发出SIGTERM/SIGHUP/SIGINT/SIGQUIT的时候，终止event的事件侦听循环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sig) &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGTERM:</span><br><span class="line">        <span class="keyword">case</span> SIGHUP:</span><br><span class="line">        <span class="keyword">case</span> SIGQUIT:</span><br><span class="line">        <span class="keyword">case</span> SIGINT:</span><br><span class="line">            <span class="built_in">event_loopbreak</span>();  <span class="comment">//终止侦听event_dispatch()的事件侦听循环，执行之后的代码</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义信号处理函数</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGHUP   , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGTERM  , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGINT   , signal_handler);</span><br><span class="line">    <span class="built_in">signal</span>(SIGQUIT  , signal_handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认参数</span></span><br><span class="line">    <span class="type">char</span> *httpd_option_listen = <span class="string">&quot;0.0.0.0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_port = <span class="number">8080</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_daemon = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> httpd_option_timeout = <span class="number">120</span>; <span class="comment">//in seconds</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;http server start %s:%d\n&quot;</span>, httpd_option_listen, httpd_option_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取参数</span></span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;l:p:dt:h&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span> :</span><br><span class="line">                httpd_option_listen = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span> :</span><br><span class="line">                httpd_option_port = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span> :</span><br><span class="line">                httpd_option_daemon = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span> :</span><br><span class="line">                httpd_option_timeout = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span> :</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">                <span class="built_in">show_help</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否设置了-d，以daemon运行</span></span><br><span class="line">    <span class="keyword">if</span> (httpd_option_daemon) &#123;</span><br><span class="line">        <span class="type">pid_t</span> pid;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;fork failed&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成子进程成功，退出父进程</span></span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 使用libevent创建HTTP Server */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化event API</span></span><br><span class="line">    <span class="built_in">event_init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个http server</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">evhttp</span> *httpd;</span><br><span class="line">    httpd = <span class="built_in">evhttp_start</span>(httpd_option_listen, httpd_option_port);</span><br><span class="line">    <span class="built_in">evhttp_set_timeout</span>(httpd, httpd_option_timeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定generic callback</span></span><br><span class="line">    <span class="built_in">evhttp_set_gencb</span>(httpd, httpd_handler, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//也可以为特定的URI指定callback</span></span><br><span class="line">    <span class="comment">//evhttp_set_cb(httpd, &quot;/&quot;, specific_handler, NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始事件监听，分发</span></span><br><span class="line">    <span class="built_in">event_dispatch</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="built_in">evhttp_free</span>(httpd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> libevent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言关键字</title>
      <link href="/20200720/c/c%E8%AF%AD%E8%A8%80/"/>
      <url>/20200720/c/c%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>在C语言中static关键字有以下的作用</p><p>1，可以用来修饰局部变量。局部变量在函数内部定义的，只有在函数内部有效（作用域），其缺省的存储方式是动态存储的，即指令执行到变量定义处时才给变量分配存储单元，函数执行结束后变量的内存单元就会被释放掉（生命周期）。用static声明局部变量时，则会改变变量的存储方式，使变量成为静态局部变量，即在编译时就为变量分配内存，直到程序运行结束退出才释放内存单元。如果在子函数中的变量，如果想要这个变量在函数执行结束后不被释放掉，可以使用static修饰。</p><p>2，static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。</p><p>3，static修饰一个函数，则对函数的连接方式产生影响，这个函数的只能在本文件中调用，不能被其他文件调用。这个有点类似于C#中的private。使用静态函数的好处是，不用担心与其他文件的同名函数产生干扰，另外对函数本身也是一种保护机制。</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>​    const关键字用来定义常量，被它修饰的变量值不能再改变。</p><p>​    const在修饰变量的时候一定要初始化，否则之后就不能再进行赋值了。</p><h2 id="一，修饰指针"><a href="#一，修饰指针" class="headerlink" title="一，修饰指针"></a>一，修饰指针</h2><h3 id="1，常量指针不能通过这个指针改变变量的值，但是可以通过其他的引用来改变变量的值。"><a href="#1，常量指针不能通过这个指针改变变量的值，但是可以通过其他的引用来改变变量的值。" class="headerlink" title="1，常量指针不能通过这个指针改变变量的值，但是可以通过其他的引用来改变变量的值。"></a>1，常量指针不能通过这个指针改变变量的值，但是可以通过其他的引用来改变变量的值。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xutopia</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d\r\n&quot;</span>, x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line">x = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\nx=%d\r\n&quot;</span>, x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://gitee.com/xutopia66/imbd/raw/master/clip_image001.png" alt="img"></p><h3 id="2，常量指针指向的值不能通过这个指针改变，但是常量指针可以指向其他的地址。"><a href="#2，常量指针指向的值不能通过这个指针改变，但是常量指针可以指向其他的地址。" class="headerlink" title="2，常量指针指向的值不能通过这个指针改变，但是常量指针可以指向其他的地址。"></a>2，常量指针指向的值不能通过这个指针改变，但是常量指针可以指向其他的地址。</h3><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xutopia</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line">p = &amp;x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\r\n&quot;</span>, x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line">p = &amp;y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="https://gitee.com/xutopia66/imbd/raw/master/clip_image002.png" alt="img"></p><h3 id="3，指针常量是指针本身是一个常量不可以再指向其他地址"><a href="#3，指针常量是指针本身是一个常量不可以再指向其他地址" class="headerlink" title="3，指针常量是指针本身是一个常量不可以再指向其他地址"></a>3，指针常量是指针本身是一个常量不可以再指向其他地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> xutopia</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;x;<span class="comment">//指针常量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\r\n&quot;</span>, x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    区分常量指针和指针常量的关键就在于 * 的位置。为了方便记忆，把 * 读作“指针”，把const读作常量：</p><p>int const * x：常量指针；</p><p>int *const x：指针常量。</p><h3 id="4，指向常量的常量指针，这种指针指向的位置不能改变，指向的值也不能改变，但是依然可以通过其他应用来改变。"><a href="#4，指向常量的常量指针，这种指针指向的位置不能改变，指向的值也不能改变，但是依然可以通过其他应用来改变。" class="headerlink" title="4，指向常量的常量指针，这种指针指向的位置不能改变，指向的值也不能改变，但是依然可以通过其他应用来改变。"></a>4，指向常量的常量指针，这种指针指向的位置不能改变，指向的值也不能改变，但是依然可以通过其他应用来改变。</h3>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> xutopia</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;x;<span class="comment">//指针常量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x=%d,y=%d\r\n&quot;</span>, x, y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p=%d\r\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xutopia66/imbd/raw/master/clip_image003.png" alt="img"></p><h2 id="二，修饰函数的参数，返回值"><a href="#二，修饰函数的参数，返回值" class="headerlink" title="二，修饰函数的参数，返回值"></a>二，修饰函数的参数，返回值</h2><p>​    参数参数也可以用const来修饰，防止函数修改参数中的内容，具体特性如上诉所介绍，常量指针，指针常量，常量指针常量。函数的返回值也可以用const来修饰，不过意义不是很大。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xutopia</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">fun1</span><span class="params">(<span class="type">int</span> param1, <span class="type">int</span>* param2, <span class="type">const</span> <span class="type">int</span> param3, <span class="type">const</span> <span class="type">int</span>* param4, <span class="type">int</span>* <span class="type">const</span> param5, <span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> param6)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;param1=%d\r\n&quot;</span>, param1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*param2=%d\r\n&quot;</span>, *param2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;param3=%d\r\n&quot;</span>, param3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*param4=%d\r\n&quot;</span>, *param4);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*param5=%d\r\n&quot;</span>, *param5);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*param6=%d\r\n&quot;</span>, *param6);</span><br><span class="line"></span><br><span class="line">param1 = <span class="number">16</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;param1=%d\r\n&quot;</span>, param1);</span><br><span class="line"></span><br><span class="line">*param2 = <span class="number">13</span>;</span><br><span class="line"><span class="comment">//param3 = 14;//err</span></span><br><span class="line">param4 = &amp;param1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;param4=%d\r\n&quot;</span>, *param4);</span><br><span class="line"><span class="comment">//*param4 = 14;//err</span></span><br><span class="line"></span><br><span class="line">*param5 = <span class="number">15</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;param5=%d\r\n&quot;</span>, *param5);</span><br><span class="line"><span class="comment">//param5 = &amp;param1;//err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//param6 = &amp;param1;//err</span></span><br><span class="line"><span class="comment">//*param6 = 1;//err</span></span><br><span class="line"><span class="keyword">return</span> param5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">11</span>, b = <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span>* p1, * p2;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* re1;</span><br><span class="line"><span class="type">int</span>* re2;</span><br><span class="line">p1 = &amp;a;</span><br><span class="line">p2 = &amp;b;</span><br><span class="line">re1 = <span class="built_in">fun1</span>(<span class="number">1</span>, p1, <span class="number">3</span>, p2, p2, p2);</span><br><span class="line"><span class="comment">//re2 = fun1(1, p1, 3, p2,p2,p2);//right</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n*p1=%d\r\n&quot;</span>, *p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p2=%d\r\n&quot;</span>, *p2);</span><br><span class="line"><span class="comment">//printf(&quot;*re=%d\r\n&quot;, *re2);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*re=%d\r\n&quot;</span>, *re1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xutopia66/imbd/raw/master/clip_image004.png" alt="img"></p><h2 id="三，修饰全局变量"><a href="#三，修饰全局变量" class="headerlink" title="三，修饰全局变量"></a>三，修饰全局变量</h2><p>​    全局变量的作用域是整个文件，如果用在其他文件中用external声明，那么全局变量可以作用到其他的文件夹，为了防止全局变量在使用的过程中被不经意的修改，可以用const修饰，这样就可以防止不必要的修改。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>​    volatile关键字提醒编译器它所定义的变量随时都可能改变，因此编译后的程序每次需要存储和读取这个变量的时候，都对直接从这个地址中读取数据。</p><p>​    如果没有volatile关键字，则编译器可能优化存储和读取，如果这个变量由别的程序更新的话，将出现不一致的现象。如果用这个关键字声明变量，编译器对访问该变量的代码就不再进行优化，从而可以稳定地访问特殊的地址。</p><p>​    简而言之，volatile声明的变量，就是要求程序运行的时候，每次从这个变量的地址读取。</p><p>​    编译器优化介绍：由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache（例如STM32某些型号就支持cache），加速对内存的访问。另外在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。以上是硬件级别的优化。再看软件一级的优化：一种是在编写代码时由程序员优化，另一种是由编译器进行优化。编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），Linux 提供了一个宏解决编译器的执行顺序问题。void Barrier(void)这个函数通知编译器插入一个内存屏障，但对硬件无效，编译后的代码会把当前CPU寄存器中的所有修改过的数值存入内存，需要这些数据的时候再重新从内存中读出。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言指针</title>
      <link href="/20200720/c/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
      <url>/20200720/c/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>以下讲解是按照如下这个程序的执行顺序来讲解的</p><h1 id="一，程序中的c语言指针"><a href="#一，程序中的c语言指针" class="headerlink" title="一，程序中的c语言指针"></a>一，程序中的c语言指针</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//这是一个整形的指针</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    a的地址：%d；\r\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    b的地址：%d；\r\n&quot;</span>, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    p的地址：%d；\r\n&quot;</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    p的值：%d，现在p的值是不确定的，目前只是为p申请了地址，还没有为它赋值；\r\n&quot;</span>, p);</span><br><span class="line"></span><br><span class="line">p = &amp;a;<span class="comment">//取址运算/* p现在指向a */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    利用取址操作p = &amp;a;，把a的地址赋值给p，现在p的值是%d，也就是a的地址；\r\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    p的地址没有变化，p的地址仍然是%d，在这个地址上存储的是变量a的地址；\r\n&quot;</span>, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    利用*运算符得到指针p指向地址中的数值为%d，在刚才p已经指向变量a的地址了，所以指针p指向地址中的值是3，但是p的值仍然是a的地址；\r\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">b = *p;<span class="comment">/* b现在为a的值 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    b = *p;，现在b的值就是p指向地址中的值，也就是a的值：%d;\r\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">*p = <span class="number">5</span>;<span class="comment">/* a现在为5 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    现在利用*p为p指向地址中存储的值进行赋值：%d，这时a的值也已经改变了：%d；\r\n&quot;</span>, *p, a);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span> *p;<span class="comment">//这是一个整形的指针</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  a的地址：%d；\r\n&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  b的地址：%d；\r\n&quot;</span>, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  p的地址：%d；\r\n&quot;</span>, &amp;p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  p的值：%d，现在p的值是不确定的，目前只是为p申请了地址，还没有为它赋值；\r\n&quot;</span>, p);</span><br></pre></td></tr></table></figure><p>指针p定义的时候没有进行初始化，所以在这里，p的初始值是不确定的。</p><p>当然也可以在p定义的时候赋初值，这样p的初始值就是确定的了。</p><p>p = 1;</p><p>一元运算符&amp;可用于取一个对象的地址，如下，这时p为指向a的指针。地址运算符&amp;只能应用于内存中的对象，即变量与数组元素。它不能作用于表达式、常量或register类型的变量。</p><p>这时p的值是3930420，即变量a的地址；</p><p>利用&amp;取出p的地址仍然为3930396，没有变；</p><p>利用间接寻址<em>，</em>p可以得到指针p指向地址中的值为3，即a的值。</p><p>p = &a;//取址运算/* p现在指向a */</p><p>printf(“  利用取址操作p = &a;，把a的地址赋值给p，现在p的值是%d，也就是a的地址；\r\n”, p);</p><p>printf(“  p的地址没有变化，p的地址仍然是%d，在这个地址上存储的是变量a的地址；\r\n”, &amp;p);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a;<span class="comment">//取址运算/* p现在指向a */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    利用取址操作p = &amp;a;，把a的地址赋值给p，现在p的值是%d，也就是a的地址；\r\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    p的地址没有变化，p的地址仍然是%d，在这个地址上存储的是变量a的地址；\r\n&quot;</span>, &amp;p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    利用*运算符得到指针p指向地址中的数值为%d，在刚才p已经指向变量a的地址了，所以指针p指向地址中的值是3，但是p的值仍然是a的地址；\r\n&quot;</span>, *p);</span><br></pre></td></tr></table></figure><p>利用*可以得到p地址中的数值，这里b的值就是3，即a的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = *p;<span class="comment">/* b现在为a的值 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    b = *p;，现在b的值就是p指向地址中的值，也就是a的值：%d;\r\n&quot;</span>, b);</span><br></pre></td></tr></table></figure><p>对*p进行赋值后，也就是对p指针指向地址中的数值进行赋值，这是a的值也就变为了5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* p = <span class="number">5</span>;<span class="comment">/* a现在为5 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;    现在利用*p为p指向地址中存储的值进行赋值：%d，这时a的值也已经改变了：%d；\r\n&quot;</span>, *p, a);</span><br></pre></td></tr></table></figure><h1 id="二，图解C语言指针"><a href="#二，图解C语言指针" class="headerlink" title="二，图解C语言指针"></a>二，图解C语言指针</h1><p>定义两个变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, b; <span class="comment">//这是一个普通的整型变量</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//这是一个整形的指针</span></span><br></pre></td></tr></table></figure><p>定义后，a的地址是0x2000，p的地址是0x3000； 在定义的时候a赋的初始值是3，p没有赋初始值，所以p的值是不确定的。</p><p><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20211215000519144.png" alt="image-20211215000519144"></p><p>现在进行运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a;<span class="comment">//取址运算/* p现在指向a */</span></span><br></pre></td></tr></table></figure><p>这时内存图就变成了这样，p的地址没有变化，但是p的值变化了，此时，*p=3；</p><p><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20211215000558962.png" alt="image-20211215000558962"></p><h1 id="三，指针与函数"><a href="#三，指针与函数" class="headerlink" title="三，指针与函数"></a>三，指针与函数</h1><h2 id="指针作为函数的形参"><a href="#指针作为函数的形参" class="headerlink" title="指针作为函数的形参"></a>指针作为函数的形参</h2><p>在程序设计中，指针作为函数形参往往会带来意想不到的效果，下面用一个例程来讲解指针作为函数形参的特性。</p><p>例子：用一个函数交换两个变量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap_pointer</span><span class="params">(<span class="type">int</span>* x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = *x;</span><br><span class="line">*x = *y;</span><br><span class="line">*y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指针与函数</span></span><br><span class="line"><span class="comment">2019-05-09</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">Swap</span>(a, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\r\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\r\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">Swap_pointer</span>(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\r\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b=%d\r\n&quot;</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下图，可以明显的看出指针作为函数形参的特性。</p><p>具体讲解详见《C语言程序设计》的5.2章节。</p><h2 id="指针，结构体与函数"><a href="#指针，结构体与函数" class="headerlink" title="指针，结构体与函数"></a>指针，结构体与函数</h2><p>在C语言中，函数本身不是变量，但是也可以定义指向函数的指针。这种指针的使用方法、特性与变量指针的使用方法、特性大同小异。</p><p>下面的介绍都是围绕这段函数来讲解的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xutopia</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">maxP</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; * y ? x : *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CallbackFun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span>(*f)(<span class="type">int</span>, <span class="type">int</span> b))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>, a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = x; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  a = <span class="built_in">f</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_dat</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span>(*fun)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">  <span class="type">int</span>* (*funP)(<span class="type">int</span>, <span class="type">int</span>*);</span><br><span class="line">  <span class="built_in">void</span>(*funFun)(<span class="type">int</span>, <span class="built_in">int</span>(*f)(<span class="type">int</span>, <span class="type">int</span>));</span><br><span class="line">&#125;datTypedef;</span><br><span class="line">datTypedef s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> maxval = <span class="number">0</span>, minval = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span>* pval;</span><br><span class="line">  pval = &amp;a;</span><br><span class="line">  <span class="comment">//指针与函数</span></span><br><span class="line">  <span class="comment">//int(*p)(int a, int b);//right</span></span><br><span class="line">  <span class="built_in">int</span>(*p)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">  p = &amp;max;</span><br><span class="line">  maxval = <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max=%d\r\n&quot;</span>, maxval);</span><br><span class="line">  p = &amp;min;</span><br><span class="line">  minval = <span class="built_in">p</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;min=%d\r\n&quot;</span>, minval);</span><br><span class="line">  <span class="comment">//结构体，指针与函数</span></span><br><span class="line">  s.fun = &amp;max;</span><br><span class="line">  maxval = s.<span class="built_in">fun</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\r\nmax=%d\r\n&quot;</span>, maxval);</span><br><span class="line">  s.funP = &amp;maxP;</span><br><span class="line">  pval = s.<span class="built_in">funP</span>(<span class="number">9</span>, pval);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;max=%d\r\n&quot;</span>, pval);</span><br><span class="line">  <span class="comment">//回调函数</span></span><br><span class="line">  s.funFun = &amp;CallbackFun;</span><br><span class="line">  s.<span class="built_in">funFun</span>(<span class="number">4</span>, max);</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20211215000709577.png" alt="image-20211215000709577"></p><p>1，指针指向函数。在某些场景下，我们需要用到指针指向函数。</p><p>2，在结构体中定义函数指针。利用这样的技巧，可以实现高级语言的特性，例如类的方法，属性等，可以使得代码更加安全规范。</p><p>3，函数指针作为函数的参数。</p><h1 id="四，指针与数组"><a href="#四，指针与数组" class="headerlink" title="四，指针与数组"></a>四，指针与数组</h1><p>使用数组时，需要明白的一些事项：</p><p>​    1，申请的数组存储在相邻的内存区域中；</p><p>​    2，数组名所代表的就是该数组最开始的一个元素的地址；</p><p>​    3，对数组元素a[i]的引用也可以写成*(a+i)这种形式；</p><p>​    4，&amp;a[i]和a+i的含义是相同的，简而言之，一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。；</p><p>​    5，数组名不是变量，因此，类似于a=pa和a++形式的语句是非法的；</p><p>​    6，当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址；</p><p>​    下面通过一些例程来解释指针与数组的运用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">统计字符串长度</span></span><br><span class="line"><span class="comment">2019-05-09</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//int StrLen(char *s)//数组作为形参有两种写法“char s[]”、“char *s”，效果一样的</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrLen</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; *s != <span class="string">&#x27;\0&#x27;</span>; s++)</span><br><span class="line">n++;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2019-05-09</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Array_pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* p;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数组[%2d]的地址:%d\r\n&quot;</span>, i, &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将指针p指向数组arr的第0个元素\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//将指针p指向数组arr的第0个元素</span></span><br><span class="line">p = &amp;arr[<span class="number">0</span>];</span><br><span class="line">p = arr;<span class="comment">//也可以写成这种形式，因为数组名所代表的就是该数组最开始的一个元素的地址</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[%d]=%d\r\n&quot;</span>, i, *(p++));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;将指针p指向数组arr的第3个元素\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//将指针p指向数组arr的第3个元素</span></span><br><span class="line"><span class="comment">//打印出来的结果可以看到，最后面3个地址的数值是不确定的</span></span><br><span class="line">p = &amp;arr[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[%d]=%d\r\n&quot;</span>, i, *(p++));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;安全的做法应该是\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//安全的做法应该是</span></span><br><span class="line">p = &amp;arr[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span> - <span class="number">3</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[%d]=%d\r\n&quot;</span>, i, *(p++));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;对数组也可以进行如下方式的使用\r\n&quot;</span>);</span><br><span class="line"><span class="comment">//对数组也可以进行如下方式的使用</span></span><br><span class="line"><span class="comment">//printf(&quot;arr[%d]=%d\r\n&quot;, i, *(arr++));//数组名不是变量，因此，类似于arr=p和arr++形式的语句是非法的</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[%d]=%d\r\n&quot;</span>, i, *(arr + i));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* str = <span class="string">&quot;hello,word&quot;</span>;</span><br><span class="line">n = <span class="built_in">StrLen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%d\r\n&quot;</span>, n);</span><br><span class="line">n = <span class="built_in">StrLen</span>(&amp;str[<span class="number">2</span>]);<span class="comment">//当然，这里可以只传入数组的一部分</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;n=%d\r\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20211215000835686.png" alt="image-20211215000835686"></p><h1 id="五，地址算术运算"><a href="#五，地址算术运算" class="headerlink" title="五，地址算术运算"></a>五，地址算术运算</h1><p>通过以下这个例子讲解地址算术运算</p><p>​    这是一个不完善的存储分配程序。它由两个函数组成。第一个函数alloc(n)返回一个指向n个连续字符存储单元的指针，alloc函数的调用者可利用该指针存储字符序列。第二个函数afree(p)释放已分配的存储空间，以便以后重用。之所以说这两个函数是“不完善的”，是因为对afree函数的调用次序必须与调用alloc函数的次序相反。换句话说，alloc与afree以栈的方式（即后进先出的列表）进行存储空间的管理。标准库中提供了具有类似功能的函数malloc和free，它们没有上述限制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ALLOCSIZE 10000 <span class="comment">/* 可用空间大小 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> allocbuf[ALLOCSIZE];<span class="comment">/* alloc使用的存储区 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span>* allocp = allocbuf; <span class="comment">/* 下一个空闲位置 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">alloc</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">/* 返回指向n个字符的指针 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (allocbuf + ALLOCSIZE - allocp &gt;= n) &#123; <span class="comment">/* 有足够的空闲空间 */</span></span><br><span class="line">allocp += n;</span><br><span class="line"><span class="keyword">return</span> allocp - n; <span class="comment">/* 分配前的指针 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* 空间不够 */</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">afree</span><span class="params">(<span class="type">char</span>* p)</span> <span class="comment">/* 释放p指向的存储区 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)</span><br><span class="line">allocp = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指针运算</span></span><br><span class="line"><span class="comment">2019-05-09</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pointer_cal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span>* allAddr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空闲地址:%d\r\n&quot;</span>, allocp);</span><br><span class="line">allAddr = <span class="built_in">alloc</span>(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空闲地址:%d\r\n&quot;</span>, allocp);</span><br><span class="line"><span class="built_in">afree</span>(allAddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;空闲地址:%d\r\n&quot;</span>, allocp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/xutopia66/imbd/raw/master/image-20211215000916225.png" alt="image-20211215000916225"></p><p>未完，待续</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++的左值(lvalue)，右值(rvalue)，移动语义(move)，完美转发(forward)</title>
      <link href="/20200720/c/c++%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/"/>
      <url>/20200720/c/c++%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="c-的左值-lvalue-，右值-rvalue-，移动语义-move-，完美转发-forward"><a href="#c-的左值-lvalue-，右值-rvalue-，移动语义-move-，完美转发-forward" class="headerlink" title="c++的左值(lvalue)，右值(rvalue)，移动语义(move)，完美转发(forward)"></a>c++的左值(lvalue)，右值(rvalue)，移动语义(move)，完美转发(forward)</h3><p><strong>c++的左值，右值 精辟总结</strong></p><blockquote><p>当一个对象被用作右值的时候，使用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）<a href="https://blog.csdn.net/edwardlulinux/article/details/80865957">左值右值，完美转发参考文档</a>。</p></blockquote><p>左值持久，右值短暂；move：显示地将一个左值转换为对应右值的引用类型，还可以获取绑定到左值上的右值引用，int&amp;&amp; rr3 = std::move(rrl); 使用move就意味着<strong>除了对rrl赋值或销毁它外</strong>，我们不再使用它。</p><p>std::forward<T>()与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型，可以使用std::forward实现<strong>完美转发</strong>。</p><p><strong>移动语义解决了无用拷贝的问题：移动构造函数</strong>；</p><p><strong>右值引用：函数的返回值</strong>。</p><p> int&amp; 左值引用</p><p>int&amp;&amp; 右值引用</p><h3 id="c-中无用拷贝的情况"><a href="#c-中无用拷贝的情况" class="headerlink" title="c++中无用拷贝的情况"></a>c++中无用拷贝的情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*类里面 没有移动构造函数</span></span><br><span class="line"><span class="comment">这样就会使用 copy construct function，会导致大量无用的 memory copy。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string desc; </span><br><span class="line">    <span class="type">int</span> * arr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">Test</span>():<span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;default constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>];</span><br><span class="line">        <span class="built_in">copy</span>(t.arr,t.arr+<span class="number">5000</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor &quot;</span> &lt;&lt; desc &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> [] arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">createTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    Test reusable;</span><br><span class="line">    reusable.desc = <span class="string">&quot;reusable&quot;</span>;</span><br><span class="line">    <span class="function">Test <span class="title">duplicated</span><span class="params">(reusable)</span></span>;</span><br><span class="line">    duplicated.desc = <span class="string">&quot;duplicated&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(createTest())</span></span>;</span><br><span class="line">    t.desc = <span class="string">&quot;t&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default constructor</span><br><span class="line">copy constructor</span><br><span class="line">default constructor</span><br><span class="line">end</span><br><span class="line">destructor t</span><br><span class="line">destructor duplicated</span><br><span class="line">destructor reusable</span><br></pre></td></tr></table></figure><h3 id="使用移动语义避免无用的拷贝"><a href="#使用移动语义避免无用的拷贝" class="headerlink" title="使用移动语义避免无用的拷贝"></a>使用移动语义避免无用的拷贝</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*使用移动 construct function，避免无用的memory copy。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    string desc;</span><br><span class="line">    <span class="type">int</span> * arr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">Test</span>():<span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;__default constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;__copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>]; <span class="comment">//在这里要将 t.arr 置为空，因为经过move之后，我们认为不在使用这个值了，避免在新的对象中把指针释放后，原来的对象中存在野指针的现象</span></span><br><span class="line">        <span class="built_in">copy</span>(t.arr,t.arr+<span class="number">5000</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;&amp; t): <span class="built_in">arr</span>(t.arr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;__move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        t.arr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..destructor &quot;</span> &lt;&lt; desc &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> [] arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">createTest</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    Test rt;</span><br><span class="line">    rt.desc = str;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;createTest:&quot;</span>&lt;&lt;&amp;rt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test reusable;</span><br><span class="line">    reusable.desc = <span class="string">&quot;reusable&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;reusable.arr &quot;</span>&lt;&lt;reusable.arr&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Test <span class="title">duplicated</span><span class="params">(std::move(reusable))</span></span>;</span><br><span class="line">    duplicated.desc = <span class="string">&quot;duplicated&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;reusable.arr &quot;</span>&lt;&lt;reusable.arr&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;duplicated.arr &quot;</span>&lt;&lt;duplicated.arr&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;rvalue--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Test&amp;&amp; rt1 = <span class="built_in">createTest</span>(<span class="string">&quot;rval&quot;</span>);      <span class="comment">//使用右值引用接收</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;rt1.arr &quot;</span>&lt;&lt;rt1.arr&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;no rvalue--&quot;</span>&lt;&lt;endl;</span><br><span class="line">    Test rt2 = <span class="built_in">createTest</span>(<span class="string">&quot;normalVal&quot;</span>);      <span class="comment">//不使用右值引用接收，可以看到这里比使用右值引用接收 多了一次构造和析构（createTest中的临时对象）</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;createTest:&quot;</span>&lt;&lt;&amp;rt2&lt;&lt;endl;        <span class="comment">//尴尬，其实这里编译器已经做了优化了，可以看到第地址一样</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;rt2.arr &quot;</span>&lt;&lt;rt2.arr&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__default constructor</span><br><span class="line">reusable.arr 0x56521b946e70</span><br><span class="line">__move constructor</span><br><span class="line">reusable.arr 0</span><br><span class="line">duplicated.arr 0x56521b946e70</span><br><span class="line">rvalue--</span><br><span class="line">__default constructor</span><br><span class="line">createTest:0x7ffd092ea390</span><br><span class="line">rt1.arr 0x56521b94c0b0</span><br><span class="line">no rvalue--</span><br><span class="line">__default constructor</span><br><span class="line">createTest:0x7ffd092ea3c0</span><br><span class="line">createTest:0x7ffd092ea3c0</span><br><span class="line">rt2.arr 0x56521b950ee0</span><br><span class="line">end</span><br><span class="line">..destructor normalVal</span><br><span class="line">..destructor rval</span><br><span class="line">..destructor duplicated</span><br><span class="line">..destructor reusable</span><br></pre></td></tr></table></figure><h3 id="左值引用右值引用"><a href="#左值引用右值引用" class="headerlink" title="左值引用右值引用"></a>左值引用右值引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左值引用和右值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const int &amp; &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> &amp; i)</span> </span>&#123;  cout &lt;&lt; <span class="string">&quot;int &amp; &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> &amp;&amp; i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;int &amp;&amp; &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;&amp; i)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const int &amp;&amp; &quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">foo</span>(i);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">foo</span>([]()-&gt;<span class="type">const</span> <span class="type">int</span> &amp;&amp; &#123;<span class="keyword">return</span> <span class="number">2</span>;&#125;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在main当中调用relay，Test的临时对象作为一个右值传入relay，在relay当中又被转发给了func，那这时候转发</span></span><br><span class="line"><span class="comment">给func的参数t也应当是一个右值。也就是说，我们希望：当relay的参数是右值的时候，func的参数也是右值；当</span></span><br><span class="line"><span class="comment">relay的参数是左值的时候，func的参数也是左值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> * arr&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">    <span class="built_in">Test</span>():<span class="built_in">arr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) &#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;default constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp; t) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5000</span>];</span><br><span class="line">        <span class="built_in">copy</span>(t.arr,t.arr+<span class="number">5000</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(Test &amp;&amp; t): <span class="built_in">arr</span>(t.arr) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        t.arr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">delete</span> [] arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//完美转发</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">relay1</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in relay &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// relay(Test());</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;end&quot;&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">relay1</span>(<span class="built_in">Test</span>());</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;end&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++的bind使用方法</title>
      <link href="/20200720/c/c++%E7%9A%84bind/"/>
      <url>/20200720/c/c++%E7%9A%84bind/</url>
      
        <content type="html"><![CDATA[<h3 id="c-的bind使用方法"><a href="#c-的bind使用方法" class="headerlink" title="c++的bind使用方法"></a>c++的bind使用方法</h3><p> 除了容器有适配器之外，其实函数也提供了适配器，适配器的特点就是将一个类型改装成为拥有子集功能的新的类型。其中函数的适配器典型的就是通过<code>std::bind</code>来实现。 </p><p>std::bind函数定义在头文件functional中，是一个函数模板，它就像一个函数适配器，接受一个可调用对象（callable object），生成一个新的可调用对象来“适应”原对象的参数列表。一般而言，我们用它可以把一个原本接收N个参数的函数fn，通过绑定一些参数，返回一个接收M个（M可以大于N，但这么做没什么意义）参数的新函数。同时，使用std::bind函数还可以实现参数顺序调整等操作。 </p><p> 如<a href="https://zh.cppreference.com/w/cpp/named_req/Callable"><em>可调用</em> <em>(Callable)</em> </a>中描述，调用指向非静态成员函数指针或指向非静态数据成员指针时，首参数必须是引用或指针（可以包含智能指针，如 <a href="https://zh.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 与 <a href="https://zh.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>），指向将访问其成员的对象。 </p><p><a href="https://zh.cppreference.com/w/cpp/utility/functional/bind">官方示例</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">int</span> n3, <span class="type">const</span> <span class="type">int</span>&amp; n4, <span class="type">int</span> n5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n4 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n5 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n1+n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// 对于 _1, _2, _3...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 演示参数重排序和按引用传递</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// （ _1 与 _2 来自 std::placeholders ，并表示将来会传递给 f1 的参数）</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(f, _2, <span class="number">42</span>, _1, std::<span class="built_in">cref</span>(n), n);</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1001</span>); <span class="comment">// 1 为 _1 所绑定， 2 为 _2 所绑定，不使用 1001</span></span><br><span class="line">                    <span class="comment">// 进行到 f(2, 42, 1, n, 7) 的调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 嵌套 bind 子表达式共享占位符</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(f, _3, std::<span class="built_in">bind</span>(g, _3), _3, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>); <span class="comment">// 进行到 f(12, g(12), 12, 4, 5); 的调用</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 常见使用情况：以分布绑定 RNG</span></span><br><span class="line">    std::default_random_engine e;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">d</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    std::function&lt;<span class="type">int</span>()&gt; rnd = std::<span class="built_in">bind</span>(d, e); <span class="comment">// e 的一个副本存储于 rnd</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10</span>; ++n)</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">rnd</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定指向成员函数指针</span></span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">auto</span> f3 = std::<span class="built_in">bind</span>(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, _1);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 绑定指向数据成员指针</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = std::<span class="built_in">bind</span>(&amp;Foo::data, _1);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f4</span>(foo) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 智能指针亦能用于调用被引用对象的成员</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f4</span>(std::<span class="built_in">make_shared</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">f4</span>(std::<span class="built_in">make_unique</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 42 1 10 7</span><br><span class="line">12 12 12 4 5</span><br><span class="line">1 5 0 2 0 8 2 2 10 8</span><br><span class="line">100</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++智能指针的使用</title>
      <link href="/20200720/c/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/20200720/c/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="c-智能指针的使用"><a href="#c-智能指针的使用" class="headerlink" title="c++智能指针的使用"></a>c++智能指针的使用</h3><p><a href="https://zh.cppreference.com/w/cpp/memory">官方参考</a></p><p>普通指针的烦恼：内存泄漏，多次释放，提前释放</p><p>智能指针 负责自动释放所指向的对象。</p><p>三种智能指针 shared_ptr，unique_ptr，weak_ptr；</p><p>将shared_ptr存放在一个容器中，不再需要它的时候，要erase掉。</p><p>allocator负责封装堆内存管理的对象，它们在整个标准库中使用，特别是STL容器使用它们来管理容器内部的所有内存分配,大部份情况下，程序员不用理会，标准容器使用默认的分配器称为std :: allocator。</p><h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>  shared_ptr</p><p>  多个指针指向相同的对象；</p><p>  使用引用计数，引用计数是线程安全的，但是对象的读写需要加锁。</p><p>  不可以直接将指针直接赋值给一个智能指针，因为指针指针是一个类。</p><p>  get获取原始指针</p><p>  最大的陷阱就是循环引用，这会导致内存无法正确释放，导致内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;  Base::Base()\n&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// 注意：此处非虚析构函数 OK</span></span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;  Base::~Base()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;  Derived::Derived()\n&quot;</span>; &#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;  Derived::~Derived()\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thr</span><span class="params">(std::shared_ptr&lt;Base&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::shared_ptr&lt;Base&gt; lp = p; <span class="comment">// 线程安全，虽然自增共享的 use_count</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">static</span> std::mutex io_mutex;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;local pointer in a thread:\n&quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;  lp.get() = &quot;</span> &lt;&lt; lp.<span class="built_in">get</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;, lp.use_count() = &quot;</span> &lt;&lt; lp.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Base&gt; p = std::<span class="built_in">make_shared</span>&lt;Derived&gt;();</span><br><span class="line"> </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Created a shared Derived (as a pointer to Base)\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;  p.get() = &quot;</span> &lt;&lt; p.<span class="built_in">get</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, p.use_count() = &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(thr, p)</span>, <span class="title">t2</span><span class="params">(thr, p)</span>, <span class="title">t3</span><span class="params">(thr, p)</span></span>;</span><br><span class="line">    p.<span class="built_in">reset</span>(); <span class="comment">// 从 main 释放所有权</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared ownership between 3 threads and released\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;ownership from main:\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;  p.get() = &quot;</span> &lt;&lt; p.<span class="built_in">get</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot;, p.use_count() = &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    t1.<span class="built_in">join</span>(); t2.<span class="built_in">join</span>(); t3.<span class="built_in">join</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;All threads completed, the last one deleted Derived\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Base::Base()</span><br><span class="line">  Derived::Derived()</span><br><span class="line">Created a shared Derived (as a pointer to Base)</span><br><span class="line">  p.get() = 0x2299b30, p.use_count() = 1</span><br><span class="line">Shared ownership between 3 threads and released</span><br><span class="line">ownership from main:</span><br><span class="line">  p.get() = 0, p.use_count() = 0</span><br><span class="line">local pointer in a thread:</span><br><span class="line">  lp.get() = 0x2299b30, lp.use_count() = 5</span><br><span class="line">local pointer in a thread:</span><br><span class="line">  lp.get() = 0x2299b30, lp.use_count() = 3</span><br><span class="line">local pointer in a thread:</span><br><span class="line">  lp.get() = 0x2299b30, lp.use_count() = 2</span><br><span class="line">  Derived::~Derived()</span><br><span class="line">  Base::~Base()</span><br><span class="line">All threads completed, the last one deleted Derived</span><br></pre></td></tr></table></figure><h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>  是为了配合shared_ptr而引入的一种智能指针，没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况。</p><p>  weak_ptr可以从一个shared_ptr或者另一个weak_ptr对象构造，获得资源的观测权。但weak_ptr没有共享资源，它的构造不会引起指针引用计数的增加。</p><p>  成员函数expired()的功能等价于use_count()==0,</p><p>  weak_ptr可以使用一个非常重要的成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"> </span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; gw;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">observe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;use_count == &quot;</span> &lt;&lt; gw.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> spt = gw.<span class="built_in">lock</span>()) &#123; <span class="comment">// 使用之前必须复制到 shared_ptr</span></span><br><span class="line">std::cout &lt;&lt; *spt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;gw is expired\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> sp = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">gw = sp;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">observe</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">observe</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_count == 1: 42</span><br><span class="line">use_count == 0: gw is expired</span><br></pre></td></tr></table></figure><h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p>  unique_ptr</p><p>  唯一拥有对象</p><p>  通过reset方法重新指定</p><p>  通过release方法释放所有权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;B::bar\n&quot;</span>; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">B</span>() = <span class="keyword">default</span>;<span class="comment">//父类的析构函数需要定义为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">D</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;D::D\n&quot;</span>;  &#125;</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;D::~D\n&quot;</span>;  &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;D::bar\n&quot;</span>;  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 消费 unique_ptr 的函数能以值或以右值引用接收它</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;D&gt; <span class="title">pass_through</span><span class="params">(std::unique_ptr&lt;D&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p-&gt;<span class="built_in">bar</span>();</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_file</span><span class="params">(std::FILE* fp)</span> </span>&#123; std::<span class="built_in">fclose</span>(fp); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;unique ownership semantics demo\n&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;D&gt;(); <span class="comment">// p 是占有 D 的 unique_ptr</span></span><br><span class="line">      <span class="keyword">auto</span> q = <span class="built_in">pass_through</span>(std::<span class="built_in">move</span>(p)); </span><br><span class="line">      <span class="built_in">assert</span>(!p); <span class="comment">// 现在 p 不占有任何内容并保有空指针</span></span><br><span class="line">      q-&gt;<span class="built_in">bar</span>();   <span class="comment">// 而 q 占有 D 对象</span></span><br><span class="line">  &#125; <span class="comment">// ~D 调用于此</span></span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Runtime polymorphism demo\n&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;B&gt; p = std::<span class="built_in">make_unique</span>&lt;D&gt;(); <span class="comment">// p 是占有 D 的 unique_ptr</span></span><br><span class="line">                                                  <span class="comment">// 作为指向基类的指针</span></span><br><span class="line">    p-&gt;<span class="built_in">bar</span>(); <span class="comment">// 虚派发</span></span><br><span class="line"> </span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;B&gt;&gt; v;  <span class="comment">// unique_ptr 能存储于容器</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">make_unique</span>&lt;D&gt;());</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(p));</span><br><span class="line">    v.<span class="built_in">emplace_back</span>(<span class="keyword">new</span> D);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p: v) p-&gt;<span class="built_in">bar</span>(); <span class="comment">// 虚派发</span></span><br><span class="line">  &#125; <span class="comment">// ~D called 3 times</span></span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Custom deleter demo\n&quot;</span>;</span><br><span class="line">  std::<span class="built_in">ofstream</span>(<span class="string">&quot;demo.txt&quot;</span>) &lt;&lt; <span class="string">&#x27;x&#x27;</span>; <span class="comment">// 准备要读的文件</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function">std::unique_ptr&lt;std::FILE, <span class="title">void</span> <span class="params">(*)</span><span class="params">(std::FILE*)</span> &gt; <span class="title">fp</span><span class="params">(std::fopen(<span class="string">&quot;demo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                                                           close_file)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(fp) <span class="comment">// fopen 可以打开失败；该情况下 fp 保有空指针</span></span><br><span class="line">        std::cout &lt;&lt; (<span class="type">char</span>)std::<span class="built_in">fgetc</span>(fp.<span class="built_in">get</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125; <span class="comment">// fclose() 调用于此，但仅若 FILE* 不是空指针</span></span><br><span class="line">    <span class="comment">// （即 fopen 成功）</span></span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Custom lambda-expression deleter demo\n&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    std::unique_ptr&lt;D, std::function&lt;<span class="type">void</span>(D*)&gt;&gt; <span class="built_in">p</span>(<span class="keyword">new</span> D, [](D* ptr)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;destroying from a custom deleter...\n&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;);  <span class="comment">// p 占有 D</span></span><br><span class="line">    p-&gt;<span class="built_in">bar</span>();</span><br><span class="line">  &#125; <span class="comment">// 调用上述 lambda 并销毁 D</span></span><br><span class="line"> </span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Array form of unique_ptr demo\n&quot;</span>;</span><br><span class="line">  &#123;</span><br><span class="line">      std::unique_ptr&lt;D[]&gt; p&#123;<span class="keyword">new</span> D[<span class="number">3</span>]&#125;;</span><br><span class="line">  &#125; <span class="comment">// 调用 ~D 3 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">unique ownership semantics demo</span><br><span class="line">D::D</span><br><span class="line">D::bar</span><br><span class="line">D::bar</span><br><span class="line">D::~D</span><br><span class="line">Runtime polymorphism demo</span><br><span class="line">D::D</span><br><span class="line">D::bar</span><br><span class="line">D::D</span><br><span class="line">D::D</span><br><span class="line">D::bar</span><br><span class="line">D::bar</span><br><span class="line">D::bar</span><br><span class="line">D::~D</span><br><span class="line">D::~D</span><br><span class="line">D::~D</span><br><span class="line">Custom deleter demo</span><br><span class="line">x</span><br><span class="line">Custom lambda-expression deleter demo</span><br><span class="line">D::D</span><br><span class="line">D::bar</span><br><span class="line">destroying from a custom deleter...</span><br><span class="line">D::~D</span><br><span class="line">Array form of unique_ptr demo</span><br><span class="line">D::D</span><br><span class="line">D::D</span><br><span class="line">D::D</span><br><span class="line">D::~D</span><br><span class="line">D::~D</span><br><span class="line">D::~D</span><br></pre></td></tr></table></figure><h3 id="shared-ptr循环引用的内存泄漏问题"><a href="#shared-ptr循环引用的内存泄漏问题" class="headerlink" title="shared_ptr循环引用的内存泄漏问题"></a>shared_ptr循环引用的内存泄漏问题</h3><p>如下对象建模——家长与子女：a Parent has a Child, a Child knowshis/her Parent。</p><p>从程序的运行中可以看到最终资源没有得到释放。</p><p> 一个智能指针在创建一个对象的时候初始化引用计数为 1，并把自己的指针指向创建的对象。但这个引用计数在何处？在智能指针内部？非也，这个计数是一个单独的对象来实现的，如图1，当另外一个智能指针指向这个对象的时候，便找到与这个对象对应的计数对象，并加一个引用，即 use_count++。这样多个智能指针对象便可以使用相同的引用计数。 </p><p><img src="https://gitee.com/xutopia66/imbd/raw/master/1640778568864.png" alt="image-1640778568864"></p><p>下面程序中，当指针p释放时，由于指针c-&gt;ParentPtr还在引用着new Child，所以这时（new Child）的use_count从2减为1。同理当指针c释放时，由于p-&gt;ChildPtr还在引用着new Parent，所以这时（new Parent）的use_count从2减为1。最终，内存没有被释放完全。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(std::shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(std::shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    std::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p.use_count() = &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c.use_count() = &quot;</span> &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p.use_count() = &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl; </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c.use_count() = &quot;</span> &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p.use_count() = &quot;</span> &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c.use_count() = &quot;</span> &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p.use_count() = &quot;</span> &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;c.use_count() = &quot;</span> &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.use_count() = 1</span><br><span class="line">c.use_count() = 1</span><br><span class="line">p.use_count() = 2</span><br><span class="line">c.use_count() = 2</span><br><span class="line">p.use_count() = 2</span><br><span class="line">c.use_count() = 2</span><br><span class="line"></span><br><span class="line">p.use_count() = 1</span><br><span class="line">c.use_count() = 1</span><br></pre></td></tr></table></figure><h3 id="shared-ptr循环引用的内存泄漏问题解决"><a href="#shared-ptr循环引用的内存泄漏问题解决" class="headerlink" title="shared_ptr循环引用的内存泄漏问题解决"></a>shared_ptr循环引用的内存泄漏问题解决</h3><p>如下，在两个需要互相引用的类的内部，使用weak_ptr智能指针引用对方，来避免循环引用导致的内存泄漏问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;Child&gt; ChildPtr;</span></span><br><span class="line">    std::weak_ptr&lt;Child&gt; ChildPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setChild</span><span class="params">(std::shared_ptr&lt;Child&gt; child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ChildPtr = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new shared_ptr</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ChildPtr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Parent</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;Parent&gt; ParentPtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setPartent</span><span class="params">(std::shared_ptr&lt;Parent&gt; parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;ParentPtr = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;ParentPtr.<span class="built_in">use_count</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Child</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::weak_ptr&lt;Parent&gt; wpp;</span><br><span class="line">    std::weak_ptr&lt;Child&gt; wpc;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Parent&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> Parent)</span></span>;</span><br><span class="line">        <span class="function">std::shared_ptr&lt;Child&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> Child)</span></span>;</span><br><span class="line">        p-&gt;<span class="built_in">setChild</span>(c);</span><br><span class="line">        c-&gt;<span class="built_in">setPartent</span>(p);</span><br><span class="line">        wpp = p;</span><br><span class="line">        wpc = c;</span><br><span class="line">        std::cout &lt;&lt; p.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">        std::cout &lt;&lt; c.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; wpp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 0</span></span><br><span class="line">    std::cout &lt;&lt; wpc.<span class="built_in">use_count</span>() &lt;&lt; std::endl;  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
